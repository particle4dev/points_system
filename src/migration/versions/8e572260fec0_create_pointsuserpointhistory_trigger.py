"""Create PointsUserPointHistory trigger

Revision ID: 8e572260fec0
Revises: 3638a3631287
Create Date: 2025-08-21 10:53:24.190923

"""
import sqlmodel
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '8e572260fec0'
down_revision: Union[str, None] = '3638a3631287'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

# --- Define Trigger and Function Names for clarity and reusability ---
TRIGGER_FUNC_NAME = "log_points_history"  # The name of the PostgreSQL function that will be executed.
TRIGGER_NAME = "trigger_log_points_history"  # The name of the trigger itself.
SOURCE_TABLE = "points_user_campaign_points"  # The table that will be monitored for changes.
TARGET_TABLE = "points_user_point_history"  # The table where the audit logs (history) will be stored.


# --- SQL for the Trigger Function ---
# This PL/pgSQL function contains the core logic for the audit trail.
# It is designed to be executed by the trigger whenever a change occurs on the SOURCE_TABLE.
# The function inspects the type of operation (INSERT, UPDATE, DELETE) and calculates
# the change in points (`points_delta`). It then inserts a new row into the
# history table (`TARGET_TABLE`) to record this change.
TRIGGER_FUNCTION_SQL = f"""
CREATE OR REPLACE FUNCTION {TRIGGER_FUNC_NAME}()
RETURNS TRIGGER AS $$
DECLARE
    -- Declare variables to hold the calculated delta and contextual data.
    v_points_delta NUMERIC;
    v_source_id UUID;
    v_wallet_address VARCHAR;
    v_campaign_id UUID;
    v_point_type_slug VARCHAR;
BEGIN
    -- TG_OP is a special variable in PostgreSQL that contains the operation type.
    -- Determine the delta and affected entities based on the operation.
    IF (TG_OP = 'INSERT') THEN
        -- For a new record, the change is simply the total points being added.
        -- NEW is a special variable representing the row being inserted.
        v_points_delta := NEW.points_earned;
        v_source_id := NEW.id;
        v_wallet_address := NEW.wallet_address;
        v_campaign_id := NEW.campaign_id;
        v_point_type_slug := NEW.point_type_slug;

    ELSIF (TG_OP = 'UPDATE') THEN
        -- For an update, the change is the difference between the new and old values.
        -- OLD is a special variable representing the row's state before the update.
        v_points_delta := NEW.points_earned - OLD.points_earned;
        v_source_id := NEW.id;
        v_wallet_address := NEW.wallet_address;
        v_campaign_id := NEW.campaign_id;
        v_point_type_slug := NEW.point_type_slug;

    ELSIF (TG_OP = 'DELETE') THEN
        -- For a deletion, the change is a negative value of the points that were removed.
        v_points_delta := -OLD.points_earned;
        v_source_id := OLD.id;
        v_wallet_address := OLD.wallet_address;
        v_campaign_id := OLD.campaign_id;
        v_point_type_slug := OLD.point_type_slug;
    END IF;

    -- Only create a history record if the points actually changed.
    -- This prevents creating zero-delta logs for updates to other fields.
    IF v_points_delta != 0 THEN
        INSERT INTO {TARGET_TABLE} (source_event_id, wallet_address, campaign_id, point_type_slug, points_change)
        VALUES (v_source_id, v_wallet_address, v_campaign_id, v_point_type_slug, v_points_delta);
    END IF;

    -- For an AFTER trigger, the return value is ignored, so we return NULL.
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
"""

# --- SQL to Attach the Trigger to the Table ---
# This statement creates the trigger and connects it to the source table.
# It specifies that the trigger should run AFTER any INSERT, UPDATE, or DELETE
# operation, for each individual row that is affected.
CREATE_TRIGGER_SQL = f"""
CREATE TRIGGER {TRIGGER_NAME}
AFTER INSERT OR UPDATE OR DELETE ON {SOURCE_TABLE}
FOR EACH ROW EXECUTE FUNCTION {TRIGGER_FUNC_NAME}();
"""

# --- SQL to Remove the Trigger and Function ---
# These statements are used in the downgrade function to cleanly remove the trigger
# and its associated function from the database.
DROP_TRIGGER_SQL = f"DROP TRIGGER IF EXISTS {TRIGGER_NAME} ON {SOURCE_TABLE};"
DROP_FUNCTION_SQL = f"DROP FUNCTION IF EXISTS {TRIGGER_FUNC_NAME}();"


def upgrade() -> None:
    """
    Applies the migration.
    This function is executed when running `alembic upgrade`.
    It creates the trigger function and then attaches the trigger to the table.
    """
    # ### commands auto generated by Alembic - please adjust! ###
    
    # Step 1: Create the PostgreSQL function that will be executed by the trigger.
    op.execute(TRIGGER_FUNCTION_SQL)
    
    # Step 2: Create the trigger itself and attach it to the `points_user_campaign_points` table.
    op.execute(CREATE_TRIGGER_SQL)
    
    # ### end Alembic commands ###


def downgrade() -> None:
    """
    Reverts the migration.
    This function is executed when running `alembic downgrade`.
    It removes the trigger and its function, restoring the database to its previous state.
    """
    # ### commands auto generated by Alembic - please adjust! ###
    
    # The order of operations is critical here.
    # We must first remove the trigger from the table before we can remove the function
    # that the trigger depends on.
    
    # Step 1: Remove the trigger from the table.
    op.execute(DROP_TRIGGER_SQL)
    
    # Step 2: Remove the trigger function itself.
    op.execute(DROP_FUNCTION_SQL)
    
    # ### end Alembic commands ###